// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import 'frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:freezed_annotation/freezed_annotation.dart' hide protected;
part 'api.freezed.dart';

// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `clone`, `clone`, `eq`, `eq`

/// Serialize credentials to YAML string.
String credentialsToYaml({required Credentials credentials}) =>
    RustLib.instance.api.crateApiCredentialsToYaml(credentials: credentials);

/// Parse credentials from YAML string.
Credentials credentialsFromYaml({required String yaml}) =>
    RustLib.instance.api.crateApiCredentialsFromYaml(yaml: yaml);

/// Serialize member credentials to YAML string.
String memberCredentialsToYaml({required MemberCredentials creds}) =>
    RustLib.instance.api.crateApiMemberCredentialsToYaml(creds: creds);

/// Parse member credentials from YAML string.
MemberCredentials memberCredentialsFromYaml({required String yaml}) =>
    RustLib.instance.api.crateApiMemberCredentialsFromYaml(yaml: yaml);

/// Serialize team to YAML string.
String teamToYaml({required Team team}) =>
    RustLib.instance.api.crateApiTeamToYaml(team: team);

/// Parse team from YAML string.
Team teamFromYaml({required String yaml}) =>
    RustLib.instance.api.crateApiTeamFromYaml(yaml: yaml);

/// Serialize team config to YAML string.
String teamConfigToYaml({required TeamConfig config}) =>
    RustLib.instance.api.crateApiTeamConfigToYaml(config: config);

/// Parse team config from YAML string.
TeamConfig teamConfigFromYaml({required String yaml}) =>
    RustLib.instance.api.crateApiTeamConfigFromYaml(yaml: yaml);

/// Serialize member to YAML string.
String memberToYaml({required Member member}) =>
    RustLib.instance.api.crateApiMemberToYaml(member: member);

/// Parse member from YAML string.
Member memberFromYaml({required String yaml}) =>
    RustLib.instance.api.crateApiMemberFromYaml(yaml: yaml);

/// Serialize interaction to YAML string.
String interactionToYaml({required Interaction interaction}) =>
    RustLib.instance.api.crateApiInteractionToYaml(interaction: interaction);

/// Parse interaction from YAML string.
Interaction interactionFromYaml({required String yaml}) =>
    RustLib.instance.api.crateApiInteractionFromYaml(yaml: yaml);

/// Serialize objective to YAML string.
String objectiveToYaml({required Objective objective}) =>
    RustLib.instance.api.crateApiObjectiveToYaml(objective: objective);

/// Parse objective from YAML string.
Objective objectiveFromYaml({required String yaml}) =>
    RustLib.instance.api.crateApiObjectiveFromYaml(yaml: yaml);

/// Configuration for backups.
@freezed
sealed class BackupConfig with _$BackupConfig {
  const factory BackupConfig({
    String? protectedBranch,
  }) = _BackupConfig;
}

/// Credentials for pincode-based authentication.
///
/// Used for authenticating team members via their pincode.
@freezed
sealed class Credentials with _$Credentials {
  const Credentials._();
  const factory Credentials({
    required String salt,
    required String pincodeHash,
  }) = _Credentials;

  /// Create new credentials from a pincode.
  ///
  /// Generates a random salt and hashes the pincode with it.
  /// Returns an error if the pincode is less than 4 characters.
  static Credentials create({required String pincode}) =>
      RustLib.instance.api.crateApiCredentialsCreate(pincode: pincode);

  /// Verify a pincode against these credentials.
  bool verify({required String pincode}) => RustLib.instance.api
      .crateApiCredentialsVerify(that: this, pincode: pincode);
}

/// A logged interaction between people.
@freezed
sealed class Interaction with _$Interaction {
  const Interaction._();
  const factory Interaction({
    required String id,
    required InteractionKind kind,
    required String from,
    required List<String> withMembers,
    required String note,
    required String timestamp,
    required bool shared,
  }) = _Interaction;

  /// Create an appreciation interaction.
  static Interaction appreciation(
          {required String from,
          required List<String> withMembers,
          required String note}) =>
      RustLib.instance.api.crateApiInteractionAppreciation(
          from: from, withMembers: withMembers, note: note);

  /// Create a new interaction.
  static Interaction create(
          {required InteractionKind kind,
          required String from,
          required List<String> withMembers,
          required String note}) =>
      RustLib.instance.api.crateApiInteractionCreate(
          kind: kind, from: from, withMembers: withMembers, note: note);

  /// Create a feedback interaction.
  static Interaction feedback(
          {required String from,
          required List<String> withMembers,
          required String note}) =>
      RustLib.instance.api.crateApiInteractionFeedback(
          from: from, withMembers: withMembers, note: note);
}

/// The kind of interaction.
enum InteractionKind {
  /// Kudos, recognition, appreciation
  appreciation,

  /// Constructive feedback
  feedback,

  /// Making amends
  apology,

  /// Regular check-in
  checkIn,

  /// Retrospective discussion
  retrospective,
  ;

  /// Get a human-readable label for this kind.
  String label() => RustLib.instance.api.crateApiInteractionKindLabel(
        that: this,
      );
}

/// A key result that measures progress toward an objective.
@freezed
sealed class KeyResult with _$KeyResult {
  const KeyResult._();
  const factory KeyResult({
    required String description,
    required double progress,
    String? notes,
  }) = _KeyResult;

  /// Clamp progress to valid range (0.0-1.0).
  static double clampProgress({required double progress}) =>
      RustLib.instance.api.crateApiKeyResultClampProgress(progress: progress);

  /// Create a new key result.
  static KeyResult create({required String description}) =>
      RustLib.instance.api.crateApiKeyResultCreate(description: description);
}

/// Configuration for linting on PRs.
@freezed
sealed class LintingConfig with _$LintingConfig {
  const factory LintingConfig({
    required bool enabled,
    String? targetBranch,
  }) = _LintingConfig;
}

/// A team member's profile.
@freezed
sealed class Member with _$Member {
  const Member._();
  const factory Member({
    required String email,
    String? name,
    String? bio,
    String? timezone,
  }) = _Member;

  /// Create a new member with the given email.
  static Member create({required String email}) =>
      RustLib.instance.api.crateApiMemberCreate(email: email);

  /// Get the display name, falling back to email if not set.
  String displayName() => RustLib.instance.api.crateApiMemberDisplayName(
        that: this,
      );
}

/// Member credentials stored in .team/members/{email}/credentials.yaml
@freezed
sealed class MemberCredentials with _$MemberCredentials {
  const MemberCredentials._();
  const factory MemberCredentials({
    required String email,
    required Credentials credentials,
  }) = _MemberCredentials;

  /// Create new member credentials.
  static MemberCredentials create(
          {required String email, required String pincode}) =>
      RustLib.instance.api
          .crateApiMemberCredentialsCreate(email: email, pincode: pincode);

  /// Verify the pincode.
  bool verify({required String pincode}) => RustLib.instance.api
      .crateApiMemberCredentialsVerify(that: this, pincode: pincode);
}

/// An objective with key results.
@freezed
sealed class Objective with _$Objective {
  const Objective._();
  const factory Objective({
    required String id,
    required String title,
    String? description,
    required List<KeyResult> keyResults,
    required OkrVisibility visibility,
    String? owner,
    String? quarter,
  }) = _Objective;

  /// Create a new objective.
  static Objective create({required String title}) =>
      RustLib.instance.api.crateApiObjectiveCreate(title: title);

  /// Calculate overall progress based on key results.
  double overallProgress() =>
      RustLib.instance.api.crateApiObjectiveOverallProgress(
        that: this,
      );
}

/// Visibility level for OKRs.
enum OkrVisibility {
  /// Only visible to the owner
  private,

  /// Visible to team members
  shared,
  ;

  static Future<OkrVisibility> default_() =>
      RustLib.instance.api.crateApiOkrVisibilityDefault();
}

/// Configuration for publishing markdown files.
@freezed
sealed class PublishConfig with _$PublishConfig {
  const factory PublishConfig({
    String? manifesto,
    String? vision,
    String? okrs,
  }) = _PublishConfig;
}

/// A team with its manifesto, vision, and members.
@freezed
sealed class Team with _$Team {
  const Team._();
  const factory Team({
    required String name,
    String? manifesto,
    String? vision,
    required List<String> leaders,
    required List<String> members,
  }) = _Team;

  /// Create a new team with the given name.
  static Team create({required String name}) =>
      RustLib.instance.api.crateApiTeamCreate(name: name);

  /// Check if an email is a leader.
  bool isLeader({required String email}) =>
      RustLib.instance.api.crateApiTeamIsLeader(that: this, email: email);

  /// Check if an email is a member (including leaders).
  bool isMember({required String email}) =>
      RustLib.instance.api.crateApiTeamIsMember(that: this, email: email);
}

/// Team configuration stored in .team/config.yaml
@freezed
sealed class TeamConfig with _$TeamConfig {
  const TeamConfig._();
  const factory TeamConfig({
    PublishConfig? publish,
    WebhookConfig? webhooks,
    LintingConfig? linting,
    BackupConfig? backup,
  }) = _TeamConfig;

  /// Create an empty configuration.
  static TeamConfig create() => RustLib.instance.api.crateApiTeamConfigCreate();

  /// Create a default configuration with sensible defaults.
  static TeamConfig withDefaults() =>
      RustLib.instance.api.crateApiTeamConfigWithDefaults();
}

/// Configuration for webhook notifications.
@freezed
sealed class WebhookConfig with _$WebhookConfig {
  const factory WebhookConfig({
    String? discord,
    String? slack,
    String? signal,
  }) = _WebhookConfig;
}
